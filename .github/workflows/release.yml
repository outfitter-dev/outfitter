name: Release

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Release mode"
        required: true
        type: choice
        default: stable
        options:
          - stable
          - canary
  pull_request:
    types: [closed]
    branches: [main]
  push:
    branches: [main]
    paths:
      - ".changeset/*.md"

jobs:
  # Phase 1: Prepare release (manual trigger)
  # Versions packages, creates a release branch, and opens a PR
  prepare:
    name: Prepare Release
    if: >
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.mode != 'canary'
    concurrency:
      group: release-prepare
      cancel-in-progress: false
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # PAT required so the release PR can trigger CI workflows
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: .bun-version

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Check for changesets
        id: check
        run: |
          COUNT=$(find .changeset -maxdepth 1 -type f -name '*.md' ! -name 'README.md' 2>/dev/null | wc -l)
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          if [ "$COUNT" -eq 0 ]; then
            echo "::error::No changesets found. Nothing to release."
            exit 1
          fi
          echo "Found $COUNT changeset(s)"

      - name: Version packages
        run: bun run version-packages

      - name: Compute release title
        id: title
        run: |
          # Check if outfitter CLI was bumped (release train lead)
          OUTFITTER_VERSION=""
          if git diff --name-only -- 'apps/outfitter/package.json' | grep -q .; then
            OUTFITTER_VERSION=$(jq -r '.version' apps/outfitter/package.json)
          fi

          # Count other public package bumps
          OTHER=0
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            PRIVATE=$(jq -r '.private // false' "$file")
            [ "$PRIVATE" = "true" ] && continue
            OTHER=$((OTHER + 1))
          done < <(git diff --name-only -- 'packages/*/package.json')

          if [ -n "$OUTFITTER_VERSION" ] && [ "$OTHER" -gt 0 ]; then
            TITLE="release: outfitter v${OUTFITTER_VERSION} (+${OTHER} packages)"
          elif [ -n "$OUTFITTER_VERSION" ]; then
            TITLE="release: outfitter v${OUTFITTER_VERSION}"
          elif [ "$OTHER" -gt 0 ]; then
            TITLE="release: ${OTHER} packages"
          else
            TITLE="chore(release): version packages"
          fi

          echo "title=$TITLE" >> "$GITHUB_OUTPUT"

      - name: Build workspace artifacts
        # Release docs export commands execute the Outfitter source CLI, which
        # imports workspace packages via dist-based exports. Build first so
        # clean runners have the required runtime artifacts.
        run: bun run build
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_API: ${{ secrets.TURBO_API }}
          TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
          TURBO_REMOTE_CACHE_SIGNATURE_KEY: ${{ secrets.TURBO_REMOTE_CACHE_SIGNATURE_KEY }}

      - name: Refresh release LLM artifacts
        run: bun run sync:docs:release:llms

      - name: Create release branch and PR
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          RELEASE_TITLE: ${{ steps.title.outputs.title }}
        run: |
          BRANCH="release/$(date +%Y%m%d-%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH"
          git add -A
          git commit -m "$RELEASE_TITLE"
          git push origin "$BRANCH"
          gh pr create \
            --base main \
            --head "$BRANCH" \
            --title "$RELEASE_TITLE" \
            --body "$(cat <<'BODY'
          ## Release

          This PR was created by the release workflow. Merging it will publish all versioned packages to npm.

          **Review the changelog entries and version bumps below, then merge to publish.**
          BODY
          )" \
            --label "autorelease"

  # Canary publish (npm-only)
  # Publishes snapshot versions to npm @canary without creating GitHub releases.
  canary:
    name: Publish Canary
    if: >
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (
        github.event_name == 'workflow_dispatch' &&
        github.event.inputs.mode == 'canary' &&
        github.ref == 'refs/heads/main'
      )
    concurrency:
      group: canary-release
      cancel-in-progress: false
    runs-on: ubuntu-latest
    environment: npm-publish
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for changesets
        id: check
        run: |
          COUNT=$(find .changeset -maxdepth 1 -type f -name '*.md' ! -name 'README.md' 2>/dev/null | wc -l)
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          if [ "$COUNT" -eq 0 ]; then
            echo "No changesets found, skipping canary release"
          else
            echo "Found $COUNT changeset(s)"
          fi

      - name: Setup Bun
        if: steps.check.outputs.count != '0'
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: .bun-version

      - name: Install dependencies
        if: steps.check.outputs.count != '0'
        run: bun install --frozen-lockfile

      - name: Setup Node (for npm OIDC publish)
        if: steps.check.outputs.count != '0'
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          registry-url: "https://registry.npmjs.org"

      - name: Upgrade npm for OIDC support
        if: steps.check.outputs.count != '0'
        run: npm install -g npm@latest

      # Default to OIDC trusted publishing. Only use token auth when NPM_TOKEN
      # is explicitly provided.
      - name: Configure npm auth mode
        if: steps.check.outputs.count != '0'
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          if [ -n "$NPM_TOKEN" ]; then
            echo "Using token-based npm auth fallback"
            echo "NODE_AUTH_TOKEN=$NPM_TOKEN" >> "$GITHUB_ENV"
          else
            echo "Using OIDC trusted publishing auth"
            # setup-node may leave NODE_AUTH_TOKEN defined; clear it so npm
            # uses OIDC trusted publishing instead of token auth.
            echo "NODE_AUTH_TOKEN=" >> "$GITHUB_ENV"
          fi

      - name: Publish canary
        if: steps.check.outputs.count != '0'
        run: bun run release:canary
        env:
          NPM_CONFIG_PROVENANCE: true

  # Phase 2: Publish (release PR merged)
  # Builds and publishes packages to npm @latest
  publish:
    name: Publish to npm
    if: >
      github.event_name == 'pull_request' &&
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.labels.*.name, 'autorelease') &&
      startsWith(github.event.pull_request.head.ref, 'release/')
    concurrency:
      group: stable-release-publish
      cancel-in-progress: false
    runs-on: ubuntu-latest
    environment: npm-publish
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: .bun-version

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build
        run: bun run build
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_API: ${{ secrets.TURBO_API }}
          TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
          TURBO_REMOTE_CACHE_SIGNATURE_KEY: ${{ secrets.TURBO_REMOTE_CACHE_SIGNATURE_KEY }}

      - name: Verify CI Gate
        run: bun run verify:ci
        env:
          NO_CHANGESET: "1"
          OUTFITTER_CI_TURBO_CONCURRENCY: "2"
          OUTFITTER_CI_BUN_MAX_CONCURRENCY: "4"
          OUTFITTER_CI_TURBO_LOG_ORDER: "stream"
          OUTFITTER_CI_TURBO_OUTPUT_LOGS: "errors-only"
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_API: ${{ secrets.TURBO_API }}
          TURBO_TEAM: ${{ secrets.TURBO_TEAM }}
          TURBO_REMOTE_CACHE_SIGNATURE_KEY: ${{ secrets.TURBO_REMOTE_CACHE_SIGNATURE_KEY }}

      - name: Verify release LLM artifacts
        run: bun run verify:docs:release:llms

      - name: Upload test diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: release-test-diagnostics-${{ github.run_id }}-${{ github.run_attempt }}
          if-no-files-found: ignore
          path: |
            .outfitter/reports/ci/**
            .turbo/runs/*.json

      - name: Setup Node (for npm OIDC publish)
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          registry-url: "https://registry.npmjs.org"

      - name: Upgrade npm for OIDC support
        run: npm install -g npm@latest

      # Default to OIDC trusted publishing. Only use token auth when NPM_TOKEN
      # is explicitly provided.
      - name: Configure npm auth mode
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          if [ -n "$NPM_TOKEN" ]; then
            echo "Using token-based npm auth fallback"
            echo "NODE_AUTH_TOKEN=$NPM_TOKEN" >> "$GITHUB_ENV"
          else
            echo "Using OIDC trusted publishing auth"
            # setup-node may leave NODE_AUTH_TOKEN defined; clear it so npm
            # uses OIDC trusted publishing instead of token auth.
            echo "NODE_AUTH_TOKEN=" >> "$GITHUB_ENV"
          fi

      - name: Publish to npm
        run: bun run release
        env:
          NPM_CONFIG_PROVENANCE: true

      - name: Create git tags
        if: success()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          npx changeset tag
          git push --tags

      - name: Build canonical release notes
        if: success()
        id: canonical
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
        run: |
          set -euo pipefail

          NOTES_DIR=".outfitter/release"
          NOTES_FILE="${NOTES_DIR}/stable-notes.md"
          mkdir -p "$NOTES_DIR"

          # Handle all merge strategies:
          # - merge commit: use merge_commit_sha
          # - squash/rebase: fall back to current HEAD on main
          TARGET_SHA="${MERGE_SHA:-}"
          if [ -z "$TARGET_SHA" ] || [ "$TARGET_SHA" = "null" ]; then
            TARGET_SHA="$(git rev-parse HEAD)"
          fi

          OUTFITTER_VERSION="$(jq -r '.version' apps/outfitter/package.json)"
          OUTFITTER_OLD_VERSION="$(
            git show "${BASE_SHA}:apps/outfitter/package.json" 2>/dev/null \
              | jq -r '.version // empty'
          )"
          OUTFITTER_WAS_BUMPED=0
          if [ -n "$OUTFITTER_OLD_VERSION" ] && [ "$OUTFITTER_OLD_VERSION" != "$OUTFITTER_VERSION" ]; then
            OUTFITTER_WAS_BUMPED=1
          fi

          OUTFITTER_TAG="outfitter@${OUTFITTER_VERSION}"
          OUTFITTER_TAG_SHA="$(git rev-list -n 1 "${OUTFITTER_TAG}" 2>/dev/null || true)"

          RELEASE_TAG="$OUTFITTER_TAG"
          RELEASE_TITLE="Outfitter ${OUTFITTER_VERSION}"

          # Use outfitter@<version> only when that tag was created for this
          # release cycle's target commit. Otherwise create a per-run stable tag
          # so we don't overwrite an earlier canonical release.
          if [ "$OUTFITTER_WAS_BUMPED" -ne 1 ] || [ "$OUTFITTER_TAG_SHA" != "$TARGET_SHA" ]; then
            RELEASE_TAG="stable-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
            RELEASE_TITLE="Outfitter Stable ${GITHUB_RUN_NUMBER}"
            if git rev-parse -q --verify "refs/tags/${RELEASE_TAG}" >/dev/null; then
              EXISTING_SHA="$(git rev-list -n 1 "${RELEASE_TAG}")"
              if [ "$EXISTING_SHA" != "$TARGET_SHA" ]; then
                echo "::error::Fallback tag ${RELEASE_TAG} points to ${EXISTING_SHA}, expected ${TARGET_SHA}"
                exit 1
              fi
            else
              git tag "${RELEASE_TAG}" "${TARGET_SHA}"
              git push origin "${RELEASE_TAG}"
            fi
          fi

          {
            echo "# ${RELEASE_TITLE}"
            echo
            echo "Canonical stable release for this publish cycle."
            echo
            echo "## Package Bumps"
            echo
            echo "| Package | From | To |"
            echo "| --- | --- | --- |"
          } > "$NOTES_FILE"

          mapfile -t PACKAGE_FILES < <(
            git diff --name-only "$BASE_SHA" "$TARGET_SHA" -- \
              'apps/*/package.json' \
              'packages/*/package.json' \
              | sort -u
          )

          ROWS=0
          for file in "${PACKAGE_FILES[@]}"; do
            [ -z "$file" ] && continue

            NEW_JSON="$(cat "$file")"
            NAME="$(jq -r '.name // empty' <<<"$NEW_JSON")"
            [ -z "$NAME" ] && continue

            PRIVATE="$(jq -r '.private // false' <<<"$NEW_JSON")"
            [ "$PRIVATE" = "true" ] && continue

            NEW_VERSION="$(jq -r '.version // empty' <<<"$NEW_JSON")"
            OLD_JSON="$(git show "${BASE_SHA}:${file}" 2>/dev/null || echo '{}')"
            OLD_VERSION="$(jq -r '.version // empty' <<<"$OLD_JSON")"

            if [ -z "$NEW_VERSION" ] || [ "$OLD_VERSION" = "$NEW_VERSION" ]; then
              continue
            fi

            printf '| `%s` | `%s` | `%s` |\n' \
              "$NAME" \
              "${OLD_VERSION:-n/a}" \
              "$NEW_VERSION" \
              >> "$NOTES_FILE"
            ROWS=$((ROWS + 1))
          done

          if [ "$ROWS" -eq 0 ]; then
            echo '| _(no public package version changes detected)_ | | |' >> "$NOTES_FILE"
          fi

          {
            echo
            echo "## Policy"
            echo
            echo "- Stable publishes generate one canonical GitHub release."
            echo "- Canary publishes are npm-only (\`@canary\`) with no GitHub prerelease."
          } >> "$NOTES_FILE"

          echo "release_tag=$RELEASE_TAG" >> "$GITHUB_OUTPUT"
          echo "release_title=$RELEASE_TITLE" >> "$GITHUB_OUTPUT"
          echo "notes_file=$NOTES_FILE" >> "$GITHUB_OUTPUT"
          echo "release_target_sha=$TARGET_SHA" >> "$GITHUB_OUTPUT"

      - name: Create canonical GitHub release
        if: success()
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.canonical.outputs.release_tag }}
          RELEASE_TITLE: ${{ steps.canonical.outputs.release_title }}
          NOTES_FILE: ${{ steps.canonical.outputs.notes_file }}
          RELEASE_TARGET_SHA: ${{ steps.canonical.outputs.release_target_sha }}
        run: |
          set -euo pipefail

          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            gh release edit "$RELEASE_TAG" \
              --title "$RELEASE_TITLE" \
              --notes-file "$NOTES_FILE"
          else
            gh release create "$RELEASE_TAG" \
              --target "$RELEASE_TARGET_SHA" \
              --title "$RELEASE_TITLE" \
              --notes-file "$NOTES_FILE"
          fi
