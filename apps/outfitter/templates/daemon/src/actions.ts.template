/**
 * {{projectName}} - Daemon lifecycle actions
 */

import { spawn } from "node:child_process";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import {
	ConflictError,
	createActionRegistry,
	defineAction,
	InternalError,
	NotFoundError,
	Result,
} from "@outfitter/contracts";
import { output } from "@outfitter/cli";
import { getLockPath, getSocketPath, isDaemonAlive } from "@outfitter/daemon";
import { z } from "zod";

const TOOL_NAME = "{{binName}}";

function getDaemonPaths() {
	const socketPath = getSocketPath(TOOL_NAME);
	const lockPath = getLockPath(TOOL_NAME);
	const daemonEntrypoint = join(
		dirname(fileURLToPath(import.meta.url)),
		"daemon.js",
	);
	return { socketPath, lockPath, daemonEntrypoint };
}

const daemonHealthSchema = z
	.object({
		status: z.string(),
		uptime: z.number(),
		version: z.string(),
	})
	.passthrough();

const start = defineAction({
	id: "start",
	description: "Start the daemon",
	surfaces: ["cli"],
	input: z.object({
		foreground: z.boolean().default(false),
	}),
	output: z.object({
		mode: z.enum(["foreground", "background"]),
		pid: z.number().optional(),
	}),
	cli: {
		command: "start",
		description: "Start the daemon",
		options: [
			{
				flags: "-f, --foreground",
				description: "Run in foreground",
			},
		],
		mapInput: ({ flags }) => ({
			foreground: Boolean(flags.foreground),
		}),
	},
	handler: async (input, _ctx) => {
		const { socketPath, lockPath, daemonEntrypoint } = getDaemonPaths();

		if (await isDaemonAlive(lockPath)) {
			return Result.err(
				ConflictError.create("Daemon is already running", { toolName: TOOL_NAME }),
			);
		}

		if (input.foreground) {
			try {
				await output("Daemon starting in foreground");
				const { runDaemon } = await import("./daemon-main.js");
				await runDaemon();
				return Result.ok({ mode: "foreground" as const });
			} catch (error) {
				return Result.err(
					InternalError.create("Failed to start daemon in foreground", {
						toolName: TOOL_NAME,
						error: error instanceof Error ? error.message : String(error),
					}),
				);
			}
		}

		try {
			const daemon = spawn(process.execPath, [daemonEntrypoint], {
				detached: true,
				stdio: "ignore",
			});
			daemon.unref();

			const pid = daemon.pid;
			const suffix = pid ? ` (pid: ${pid})` : "";
			await output(`Daemon started${suffix}`);
			return Result.ok({
				mode: "background" as const,
				...(pid ? { pid } : {}),
			});
		} catch (error) {
			return Result.err(
				InternalError.create("Failed to start daemon", {
					toolName: TOOL_NAME,
					error: error instanceof Error ? error.message : String(error),
				}),
			);
		}
	},
});

const stop = defineAction({
	id: "stop",
	description: "Stop the daemon",
	surfaces: ["cli"],
	input: z.object({}),
	output: z.object({
		stopped: z.boolean(),
	}),
	cli: {
		command: "stop",
		description: "Stop the daemon",
		mapInput: () => ({}),
	},
	handler: async () => {
		const { socketPath, lockPath } = getDaemonPaths();

		if (!(await isDaemonAlive(lockPath))) {
			return Result.err(NotFoundError.create("daemon", TOOL_NAME));
		}

		try {
			const response = await fetch(`http://unix:${socketPath}:/shutdown`, {
				method: "POST",
			});
			if (!response.ok) {
				return Result.err(
					InternalError.create("Daemon shutdown request failed", {
						toolName: TOOL_NAME,
						status: response.status,
					}),
				);
			}

			await response.text();
			await output("Daemon stopped");
			return Result.ok({ stopped: true });
		} catch (error) {
			return Result.err(
				InternalError.create("Failed to stop daemon", {
					toolName: TOOL_NAME,
					error: error instanceof Error ? error.message : String(error),
				}),
			);
		}
	},
});

const status = defineAction({
	id: "status",
	description: "Check daemon status",
	surfaces: ["cli"],
	input: z.object({}),
	output: z.object({
		running: z.boolean(),
		health: daemonHealthSchema.optional(),
	}),
	cli: {
		command: "status",
		description: "Check daemon status",
		mapInput: () => ({}),
	},
	handler: async (_input, ctx) => {
		const { socketPath, lockPath } = getDaemonPaths();

		if (!(await isDaemonAlive(lockPath))) {
			await output("Daemon is not running");
			return Result.ok({ running: false });
		}

		await output("Daemon is running");

		try {
			const response = await fetch(`http://unix:${socketPath}:/health`);
			if (!response.ok) {
				ctx.logger.warn(`Health check failed with status ${response.status}`);
				return Result.ok({ running: true });
			}

			const raw = await response.json();
			const parsed = daemonHealthSchema.safeParse(raw);
			if (!parsed.success) {
				ctx.logger.warn("Daemon health payload did not match expected shape");
				return Result.ok({ running: true });
			}

			await output(JSON.stringify(parsed.data, null, 2));
			return Result.ok({ running: true, health: parsed.data });
		} catch (error) {
			ctx.logger.warn(
				`Failed to fetch daemon health: ${error instanceof Error ? error.message : String(error)}`,
			);
			return Result.ok({ running: true });
		}
	},
});

export const actions = createActionRegistry().add(start).add(stop).add(status);
