/**
 * {{projectName}} daemon main logic
 */

import { createLogger } from "@outfitter/logging";
import {
  getSocketPath,
  getLockPath,
  getDaemonDir,
  acquireDaemonLock,
  releaseDaemonLock,
} from "@outfitter/daemon";
import { mkdir } from "node:fs/promises";

const logger = createLogger({ name: "{{binName}}d" });

const TOOL_NAME = "{{binName}}";
const startTime = Date.now();

export async function runDaemon(): Promise<void> {
  const socketPath = getSocketPath(TOOL_NAME);
  const lockPath = getLockPath(TOOL_NAME);
  const daemonDir = getDaemonDir(TOOL_NAME);

  // Ensure daemon directory exists
  await mkdir(daemonDir, { recursive: true });

  // Acquire lock
  const lockResult = await acquireDaemonLock(lockPath);
  if (!lockResult.isOk()) {
    logger.error`Failed to acquire lock: ${lockResult.error.message}`;
    process.exit(1);
  }
  const lock = lockResult.value;

  logger.info`Daemon starting on ${socketPath}`;

  // Create HTTP server on Unix socket
  const server = Bun.serve({
    unix: socketPath,
    fetch(request) {
      const url = new URL(request.url);

      if (url.pathname === "/health") {
        return Response.json({
          status: "ok",
          uptime: Date.now() - startTime,
          version: "{{version}}",
        });
      }

      if (url.pathname === "/shutdown" && request.method === "POST") {
        logger.info`Shutdown requested`;
        // Schedule shutdown
        setTimeout(async () => {
          await releaseDaemonLock(lock);
          server.stop();
          process.exit(0);
        }, 100);
        return new Response("Shutting down");
      }

      return new Response("Not found", { status: 404 });
    },
  });

  // Handle signals
  const shutdown = async () => {
    logger.info`Received shutdown signal`;
    await releaseDaemonLock(lock);
    server.stop();
    process.exit(0);
  };

  process.on("SIGTERM", shutdown);
  process.on("SIGINT", shutdown);

  logger.info`Daemon running`;
}
